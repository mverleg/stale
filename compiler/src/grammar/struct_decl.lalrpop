use ::std::str::FromStr;

use crate::ast::OpCode;
use crate::ast::Expr;

grammar;

match {
    // Turn newlines into a token (they are skipped by default)
    r"(\r\n|\n|\r)(\s|\r|\n)*" => END,
} else {
    // Match string literals
    r#"("[^"]*"|([^"]*\\")*)"# => STR,
} else {
    // Ignore full-line comments
    r#"\s*#[^\r\n]*(\r\n|\n|\r)(\s|\r|\n)*"# => { },
} else {
    // Ignore any other whitespace (except newlines above)
    r"\s+" => { },
} else {
    _
}

NumLit: f64 = <s:r"[0-9]+(\.[0-9]+)?"> => f64::from_str(s).unwrap();

AddSubOp: OpCode = {
    "+" => OpCode::Add,
    "-" => OpCode::Sub,
};

MulDivOp: OpCode = {
    "*" => OpCode::Mul,
    "/" => OpCode::Div,
};

pub NullaryExpr: Expr = {
    <s:STR> => Expr::Text(s.to_string()),
    NumLit => Expr::Num(<>),
    "(" <e:NullaryExpr> ")" => e
    //<l:ExprNode> <o:MulDivOp> <r:ExprNode> => Expr::BinOp(o, l, r),
    //"(" <e:ExprNode> ")" => e,
};

//pub AddSubExpr: Expr = {
//    <l:NularyExpr> <o:AddSubOp> <r:NularyExpr> => Expr::BinOp(o, Box::new(l), Box::new(r)),
//    MulDivExpr,
//};

pub MulDivExpr: Expr = {
    <l:NullaryExpr> <o:MulDivOp> <r:NullaryExpr> => Expr::BinOp(o, Box::new(l), Box::new(r)),
    "(" <e:NullaryExpr> ")" => e
};


pub Prog: Expr = {
    NullaryExpr,
};
