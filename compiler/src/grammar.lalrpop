use ::std::str::FromStr;

use crate::ast::AssignmentDest;
use crate::ast::AssignmentKw;
use crate::ast::Assignments;
use crate::ast::Ast;
use crate::ast::BinOpCode;
use crate::ast::Block;
use crate::ast::Closure;
use crate::ast::Enum;
use crate::ast::EnumVariant;
use crate::ast::Expr;
use crate::ast::Identifier;
use crate::ast::Invoke;
use crate::ast::Struct;
use crate::ast::Type;
use crate::ast::UnaryOpCode;
use crate::ast::vec_and;

grammar;

match {
    // Match double quoted string literals
    r#""[^"]*""# => DQSTR,
    //TODO @mark: is this second half correct?
} else {
    // Match single quoted string literals
    r#"('[^']*')"# => SQSTR,
} else {
    // Reserved keywords
    r#"(abstract|alias|all|annotation|any|as|assert|async|auto|await|become|bool|box|break|by|byte|catch|class|closed|companion|const|constructor|continue|data|debug|def|default|defer|del|delegate|delegates|delete|derive|deriving|do|double|dynamic|elementwise|elif|end|eval|except|extends|extern|family|field|final|finally|float|fn|for|get|global|goto|if|impl|implements|import|in|init|inject|int|interface|internal|intersect|intersection|io|is|lambda|lateinit|lazy|let|local|loop|macro|main|match|module|move|NaN|native|nill|none|null|object|open|operator|out|override|package|param|pass|private|proof|public|pure|raise|real|rec|reified|return|sealed|select|self|set|sizeof|spawn|static|steel|super|switch|sync|synchronized|tailrec|task|test|this|throw|throws|to|trait|transient|try|type|union|unite|unsafe|until|use|val|var|vararg|virtual|volatile|when|where|while|xor|yield)"# => ERROR,
} else {
    // Ignore line comments
    r#"#[^\r\n]*(\r\n|\n|\r)(\s|\r\n|\n|\r)*"# => { },
} else {
    // Do not count NEWLINE token when preceded by ellipsis
    r"\.\.\.[ \t]*(\r\n|\n|\r)*" => { },
} else {
    // Periods have special lexing because a linebreak is allowed before
   r"(\r\n|\n|\r)+\s*\." => BrPer,
} else {
    // Periods have special lexing because a linebreak is allowed before
   r"\." => JustPeriod,
} else {
    // Turn at least one semicolons and any number of newlines into a single token (without this they are skipped)
    r";+[ \t]*( |\t|\r\n|\n|\r|;)*" => SEMICOLON,
} else {
    // Turn any remaining newlines (not preceded by semicolon, in previous rule) into a single token
    r"(\r\n|\n|\r)*" => NEWLINE,
} else {
    // Ignore any other whitespace (except newlines above)
    r"[ \t]+" => { },
    //TODO @mark: does this mean keywords can be concatenated? that is not desirable
} else {
    _
}

End: () = { SEMICOLON, NEWLINE }
Br: () = { NEWLINE? }

pub Prog: Ast = {
    Br <bs:Statements<BlockNode>> => Ast { blocks: bs },
}

// todo: guard statement

BlockNode: Block = {
    <d:StructDecl> => Block::Struct(d),
    <d:EnumDecl> => Block::Enum(d),
    <a:Assigns> => Block::Assigns(a),
    <e:Expression<Br, BrPer>> => Block::Expression(e),
}

// precedence (though some may be warnings for being confusing):
//   1 + 2 == 3 or 4  => (1 + 2) == (3 or 4)
//   1 or 2 + 4  =>  1 or (2 + 4)
//   false or false == false or true  =>  false or (false == false) or true
// B: either Br if newlines are allowed, or () if not
// P: either BrPer is newlines are allowed, or () if not
Expression<B, P>: Expr = {
    ShortClosureExpr<B, P>
}

ShortClosureExpr<B, P>: Expr = {
    <ShortClosure<B, P>> => Expr::Closure(<>),
    BoolCombineExpr<B, P>,
}

BoolCombineExpr<B, P>: Expr = {
    <l:BoolCombineExpr<B, P>> <o:BoolCombineOp> B <r:BoolCompareExpr<B, P>> => Expr::BinOp(o, Box::new(l), Box::new(r)),
    BoolCompareExpr<B, P>,
}

BoolCompareExpr<B, P>: Expr = {
    <l:BoolCompareExpr<B, P>> <o:BoolCompareOp> B <r:AddSubExpr<B, P>> => Expr::BinOp(o, Box::new(l), Box::new(r)),
    AddSubExpr<B, P>,
}

AddSubExpr<B, P>: Expr = {
    <l:AddSubExpr<B, P>> <op:AddSubOp> B <r:MulDivExpr<B, P>> => Expr::BinOp(op, Box::new(l), Box::new(r)),
    MulDivExpr<B, P>,
}

AddSubOp: BinOpCode = {
    <"+"> => BinOpCode::Add,
    <"-"> => BinOpCode::Sub,
}

MulDivExpr<B, P>: Expr = {
    <l:MulDivExpr<B, P>> <op:MulDivOp> B <r:DotExpr<B, P>> => Expr::BinOp(op, Box::new(l), Box::new(r)),
    DotExpr<B, P>,
}

MulDivOp: BinOpCode = {
    <"*"> => BinOpCode::Mul,
    <"/"> => BinOpCode::Div,
    <"%"> => BinOpCode::Modulo,
}

DotExpr<B, P>: Expr = {
    //TODO @mark: this is a problem with short lambdas: PERIOD may always have a newline independent of B
    <e:DotExpr<B, P>> MaybeBrPeriod<P> <inv:InvokeExpr<B, P>> => Expr::Dot(Box::new(e), inv),
    UnaryExpr<B, P>,
}

MaybeBrPeriod<P>: () = {
    P => {},
    JustPeriod => {},
}

UnaryExpr<B, P>: Expr = {
    <op:UnaryOp> <e:Single<B, P>> => Expr::UnaryOp(op, Box::new(e)),
    Single<B, P>,
}

Single<B, P>: Expr = {
    <s:DQSTR> => Expr::Text(s.to_string().into()),
    <s:SQSTR> => Expr::Text(s.to_string().into()),
    NumLit => Expr::Num(<>),
    <inv:InvokeExpr<B, P>> => Expr::Invoke(inv),
    <λ:MidClosure<B, P>> => Expr::Closure(λ),
    <λ:LongClosure<B, P>> => Expr::Closure(λ),
    "(" B <e:ShortClosureExpr<B, P>> ")" => e,
}

InvokeExpr<B, P>: Invoke = {
    <iden:Iden> "(" B <args:Comma<Expression<B, P>, B>> ")"  <λ:TrailingClosure?> => Invoke { iden, args: vec_and(args, λ.map(|f| Expr::Closure(f))) },
    <iden:Iden> <λ:TrailingClosure?> => Invoke { iden, args: vec_and(vec![], λ.map(|f| Expr::Closure(f))) },
}

NumLit: f64 = <s:r"[0-9]+(\.[0-9]+)?"> => f64::from_str(s).unwrap();

StructDecl: Struct = {
    "struct" <n:Iden> <gens:("[" Br <GenericList> "]")?> Br "{" Br <fs:Comma<FieldDecl, Br>> "}" => Struct {
        iden: n,
        fields: fs,
        generics: gens.unwrap_or_else(|| vec![]),
    },
}

EnumDecl: Enum = {
    "enum" <n:Iden> <gens:("[" Br <GenericList> "]")?> Br "{" Br <vs:Comma<EnumVariant, Br>> "}" => Enum {
        iden: n,
        variants: vs,
        generics: gens.unwrap_or_else(|| vec![]),
    },
}

EnumVariant: EnumVariant = {
    <StructDecl> => EnumVariant::Struct(<>),
    <EnumDecl> => EnumVariant::Enum(<>),
    <TypeUse<Br, BrPer>> => EnumVariant::Existing(<>),
}

//TODO @mark: is type inference possible in this context?
FieldDecl: (Identifier, Type) = {
    <n:Iden> ":" Br <t:TypeUse<Br, BrPer>> => (n, t),
}

Assigns: Assignments = {
    <ds:AssignDestEq+> <e:Expression<Br, BrPer>> => Assignments {
            dest: { ds },
            op: None,
            value: Box::new(e),
    },
    <d:UntypedAssignDest> <op:AssignModifier> <e:Expression<Br, BrPer>> => Assignments {
        dest: { vec![d] },
        op: Some(op),
        value: Box::new(e),
    },
}

AssignDestEq: AssignmentDest = {
    <d:AssignDest> "=" => d,
}

AssignDest: AssignmentDest = {
    <UntypedAssignDest>,
    <TypedAssignDest>,
}

UntypedAssignDest: AssignmentDest = {
    <kw:AssignmentKeyword?> <n:Iden> => AssignmentDest {
            kw: kw.unwrap_or(AssignmentKw::None),
            target: n,
            typ: None,
    },
}

TypedAssignDest: AssignmentDest = {
    <kw:AssignmentKeyword?> <n:Iden> ":" Br <t: TypeUse<Br, BrPer>> => AssignmentDest {
            kw: kw.unwrap_or(AssignmentKw::None),
            target: n,
            typ: Some(t),
    },
}

AssignmentKeyword: AssignmentKw = {
    "mut" => AssignmentKw::Mut,
    "local" => AssignmentKw::Local,
}

AssignModifier: BinOpCode = {
    // must treat modifier and equals as one token, because lookahead is at most 1 token
    "+=" => BinOpCode::Add,
    "-=" => BinOpCode::Sub,
    "*=" => BinOpCode::Mul,
    "/=" => BinOpCode::Div,
}

BoolCompareOp: BinOpCode = {
    "==" => BinOpCode::Eq,
    "!=" => BinOpCode::Neq,
    "<" => BinOpCode::Lt,
    ">" => BinOpCode::Gt,
    "<=" => BinOpCode::Le,
    ">=" => BinOpCode::Ge,
}

BoolCombineOp: BinOpCode = {
    "and" => BinOpCode::And,
    "or" => BinOpCode::Or,
    "xor" => BinOpCode::Xor,
}

UnaryOp: UnaryOpCode = {
    "!" => UnaryOpCode::Not,
    "-" => UnaryOpCode::Min,
}

ShortClosure<B, P>: Closure = {
    <c:r"(\\|\\\\)"> B <e:Expression<B, P>> =>
        Closure { blocks: vec![Block::Expression(e)], params: vec![], is_cache: c == r"\\" },
}

//TODO @mark: rename closure types
MidClosure<B, P>: Closure = {
    "{" <params:ParamList> <c:r"(\\|\\\\)"> B <bs:Statements<BlockNode>> "}" =>
        Closure { blocks: bs, params, is_cache: c == r"\\" },
}

/// Simple closures can use `\ 2 * it` or `{\ 2 * it }` syntax, but full `fun` syntax is needed for explicit captures, return, generics, fun kinds, etc
LongClosure<B, P>: Closure = {
    "fun" "(" B <params:ParamList> ")" <ret:(":" B <TypeUse<B, P>>)?> B "{" B <blocks:Statements<BlockNode>> "}" =>
        Closure { blocks, params, is_cache: false },
}

TrailingClosure: Closure = { <ShortClosure<(), ()>> NEWLINE , MidClosure<Br, BrPer> }
//TODO @mark: this is a bit weird, the only case where a newline is required but cannot be replaced by ; or something eles

ParamList: Vec<AssignmentDest> = {
    <Comma<AssignDest, Br>>,
}

GenericList: Vec<AssignmentDest> = {
    <Comma<AssignDest, Br>>,
}

TypeUse<B, P>: Type = {
    <iden:Iden> <gen:("[" <Comma<TypeUse<B, P>, B>> "]")?> => Type { iden, generics: gen.unwrap_or_else(|| vec![]), },
}

Iden: Identifier = <s:r"([a-zA-Z]|_[a-zA-Z0-9])[a-zA-Z0-9_]*"> => Identifier::new(s).unwrap();

Comma<T, B>: Vec<T> = {
    <mut v:(<T> "," B)*> <e:T> ","? B => vec_and(v, Some(e)),
    () => Vec::new(),
}

Statements<T>: Vec<T> = {
    <mut v:(<T> End)*> <e:T?> => vec_and(v, e)
}
