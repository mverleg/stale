use ::std::str::FromStr;

use crate::ast::AssignmentDest;
use crate::ast::AssignmentKw;
use crate::ast::Assignments;
use crate::ast::Ast;
use crate::ast::BinOpCode;
use crate::ast::Block;
use crate::ast::Closure;
use crate::ast::Enum;
use crate::ast::EnumVariant;
use crate::ast::Expr;
use crate::ast::Identifier;
use crate::ast::Invoke;
use crate::ast::Struct;
use crate::ast::Type;
use crate::ast::UnaryOpCode;
use crate::ast::vec_and;

grammar;

match {
    // Do not count NEWLINE token when preceded by ellipsis
    r#"\.{3}[ \t\n\r]*"# => { },
} else {
    // Periods have special lexing because a linebreak is allowed before
    r#"[ \t\n\r]*\."# => PERIOD,

    // Turn at least one semicolons and any number of newlines into a single token (without this they are skipped)
    r#";+[ \t]*( |\t|\n|\r|;)*"# => SEMICOLON,
} else {
    // Turn any remaining newlines (not preceded by semicolon, in previous rule) into a single token
    r#"(\n|\r)+"# => NEWLINE,

    // Ignore any other whitespace (except newlines above)
    r#"[ \t]+"# => { },
} else {
    _
}
//TODO @mark: match 'a+b' as a special token so as to reject it for not having whitespace

End: () = { SEMICOLON, NEWLINE }
Br: () = { NEWLINE? }

pub Prog: Ast = {
    Br <bs:Statements<BlockNode>> => Ast { blocks: bs.into_boxed_slice() },
}

// todo: guard statement

BlockNode: Block = {
    <e:Expression> => Block::Expression(e),
}

// precedence (though some may be warnings for being confusing):
//   1 + 2 == 3 or 4  => (1 + 2) == (3 or 4)
//   1 or 2 + 4  =>  1 or (2 + 4)
//   false or false == false or true  =>  false or (false == false) or true
// B: either Br if newlines are allowed, or () if not
// P: either BrPer is newlines are allowed, or () if not
Expression: Expr = {
    Conditional,
}

// TODO @mark: do if/for/while without "(..)" if possible

Conditional: Expr = {
    // could allow newline after `if` but I prefer not to
    "if" "(" <when:Expression> ")" "{" Br <yes:Expression> "}" <no:("else" "{" <Expression> "}")?> =>
            Expr::If(Box::new(when), Box::new(yes), no.map(|e| Box::new(e))),
    BoolCombineExpr,
}

// TODO @mark: match/branch/select statement

// TODO @mark: use ~ or ~= for pattern matching? i.e. can do ~= by itself if irrefutable, and inside if/while if refutable

BoolCombineExpr: Expr = {
    <l:BoolCombineExpr> <o:BoolCombineOp> Br <r:BoolCompareExpr> => Expr::BinOp(o, Box::new(l), Box::new(r)),
    BoolCompareExpr,
}

BoolCompareExpr: Expr = {
    <l:BoolCompareExpr> <o:BoolCompareOp> Br <r:AddSubExpr> => Expr::BinOp(o, Box::new(l), Box::new(r)),
    AddSubExpr,
}

AddSubExpr: Expr = {
    <l:AddSubExpr> <op:AddSubOp> Br <r:MulDivExpr> => Expr::BinOp(op, Box::new(l), Box::new(r)),
    MulDivExpr,
}

AddSubOp: BinOpCode = {
    <"+"> => BinOpCode::Add,
    <"-"> => BinOpCode::Sub,
}

MulDivExpr: Expr = {
    <l:MulDivExpr> <op:MulDivOp> Br <r:DotExpr> => Expr::BinOp(op, Box::new(l), Box::new(r)),
    DotExpr,
}

MulDivOp: BinOpCode = {
    <"*"> => BinOpCode::Mul,
    <"/"> => BinOpCode::Div,
    <"%"> => BinOpCode::Modulo,
}

DotExpr: Expr = {
    <e:DotExpr> PERIOD <inv:InvokeExpr> => Expr::Dot(Box::new(e), inv),
    UnaryExpr,
}

UnaryExpr: Expr = {
    <op:UnaryOp> <e:Single> => Expr::UnaryOp(op, Box::new(e)),
    Single,
}

Single: Expr = {
    NumLit => Expr::Num(<>),
    <inv:InvokeExpr> => Expr::Invoke(inv),
    <f:Function> => Expr::Closure(f),
    "(" Br <e:BoolCombineExpr> ")" => e,
}

InvokeExpr: Invoke = {
    <iden:Iden> "(" Br <args:Comma<Expression>> ")" <位:Function?> => Invoke {
            iden,
            args: vec_and(args, 位.map(|f| Expr::Closure(f))).into_boxed_slice()
        },
    <iden:Iden> <位:Function?> => Invoke {
            iden,
            args: vec_and(Vec::with_capacity(1), 位.map(|f| Expr::Closure(f))).into_boxed_slice()
        },
    // TODO @mark: full functions
    // TODO @mark: should numbers also be supported, for tuples?
}

NumLit: f64 = <s:r"[0-9]+(\.[0-9]+)?"> => f64::from_str(s).unwrap();

StructDecl: Struct = {
    "struct" <n:Iden> <gens:GenericList> Br "{" Br <fs:Comma<FieldDecl>> "}" => Struct {
        iden: n,
        fields: fs,
        generics: gens,
    },
}

//TODO @mark: is type inference possible in this context?
FieldDecl: (Identifier, Type) = {
    <n:Iden> ":" Br <t:TypeUse> => (n, t),
}

AssignDest: AssignmentDest = {
    <n:Iden> => AssignmentDest {
            kw: AssignmentKw::None,
            target: n,
            typ: None,
    },
}

BoolCompareOp: BinOpCode = {
    "==" => BinOpCode::Eq,
    "!=" => BinOpCode::Neq,
    "<" => BinOpCode::Lt,
    ">" => BinOpCode::Gt,
    "<=" => BinOpCode::Le,
    ">=" => BinOpCode::Ge,
}

BoolCombineOp: BinOpCode = {
    "and" => BinOpCode::And,
    "or" => BinOpCode::Or,
    "xor" => BinOpCode::Xor,
}

UnaryOp: UnaryOpCode = {
    "!" => UnaryOpCode::Not,
    "-" => UnaryOpCode::Min,
}

Function: Closure = {
    <FullFunction>,
    <Lambda>,
}

FullFunction: Closure = {
    "fn" "(" <p:ParamList> ")" <r:(":" Br <TypeUse>)?> <f:FunctionBody> =>
        //TODO @mark: use `p`
        Closure { blocks: f, params: Box::new([]) },
}

Lambda: Closure = {
    <f:FunctionBody> => Closure { blocks: f, params: Box::new([]) },
}

FunctionBody: Box<[Block]> = {
    "{" Br <bs:Statements<BlockNode>> "}" => bs.into_boxed_slice(),
}

ParamList: Box<[AssignmentDest]> = {
    <Comma<AssignDest>> => <>.into_boxed_slice(),
}

GenericList: Box<[AssignmentDest]> = {
    "<" Br <gens:Comma<AssignDest>> ">" => gens.into_boxed_slice(),
    () => Box::new([]),
}

TypeUse: Type = {
    <iden:Iden> <gen:("<" <Comma<TypeUse>> ">")?> => Type {
            iden,
            generics: gen.map(|v| v.into_boxed_slice()).unwrap_or_else(|| Box::new([])),
    },
}

// If this does not match, it may be a reserved keyword
Iden: Identifier = <s:r"([a-zA-Z]|_[a-zA-Z0-9])[a-zA-Z0-9_]*"> => Identifier::new(s).unwrap();

Comma<T>: Vec<T> = {
    <mut v:(<T> "," Br)*> <e:T> ","? Br => vec_and(v, Some(e)),
    () => Vec::new(),
}

Statements<T>: Vec<T> = {
    <mut v:(<T> End)*> <e:T?> => vec_and(v, e)
}

//TODO @mark: see if any rules are unused (is there a warning?)

