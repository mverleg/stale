use ::std::str::FromStr;
use ::tinyvec::tiny_vec;

use crate::ast::Struct;
use crate::ast::Assignments;
use crate::ast::AssignmentKw;
use crate::ast::AssignmentDest;
use crate::ast::Ast;
use crate::ast::Block;
use crate::ast::Expr;
use crate::ast::Identifier;
use crate::ast::OpCode;
use crate::ast::Type;

grammar;

match {
    // Do not count NEWLINE token when preceded by ellipsis
    r"...[ \t]*(\r\n|\n|\r)(\s|\r|\n)" => { },
} else {
    // Turn at least one semicolons and any number of newlines into a single token (without this they are skipped)
    r";+[ \t]*(\r\n|\n|\r)(;*|\s|\r|\n)+" => SEMICOLON,
} else {
    // Turn any remaining newlines (not preceded by semicolon, in previous rule) into a single token
    r"(\r\n|\n|\r)(;*|\s|\r|\n)+" => NEWLINE,
} else {
    // Match double quoted string literals
    r#"("[^"]*"|([^"]*\\")*)"# => DQSTR,
    //TODO @mark: is this second half correct?
} else {
    // Match single quoted string literals
    r#"('[^']*')"# => SQSTR,
} else {
    // Reserved keywords
    r#"(abstract|alias|all|and|annotation|any|as|async|auto|await|become|bool|box|break|by|byte|catch|class|closed|companion|const|constructor|continue|data|debug|def|default|defer|del|delegate|delegates|delete|derive|deriving|do|double|dynamic|elementwise|elif|end|enum|eval|except|extends|extern|false|family|field|final|finally|float|fn|for|fun|get|global|goto|if|impl|implements|import|in|init|inject|int|interface|internal|intersect|intersection|io|is|it|lambda|lateinit|lazy|let|local|loop|macro|main|match|module|move|NaN|native|nill|none|null|object|open|operator|or|out|override|package|param|pass|private|proof|public|pure|raise|real|rec|reified|return|sealed|select|self|set|sizeof|spawn|static|steel|super|switch|sync|synchronized|tailrec|task|test|this|throw|throws|to|trait|transient|true|try|type|union|unite|unsafe|until|use|val|var|vararg|virtual|volatile|when|where|while|with|xor|yield)"# => ERROR,
} else {
    // Ignore full-line comments
    r#"\s*#[^\r\n]*(\r\n|\n|\r)(\s|\r|\n)*"# => { },
} else {
    // Ignore any other whitespace (except newlines above)
    r"\s+" => { },
    //TODO @mark: does this mean keywords can be concatenated? that is not desirable
} else {
    _
}

End: () = { SEMICOLON, NEWLINE }
MayBreak: () = { NEWLINE? }

pub Prog: Ast = {
    MayBreak <bs:Statements<BlockNode>> => Ast { blocks: bs },
};

// todo: guard statement

BlockNode: Block = {
    <d:StructDecl> => Block::Struct(d),
    <a:Assert> => Block::Assert(a),
    <a:Assigns> => Block::Assigns(a),
    <e:Expression> => Block::Expression(e),
}

Expression: Expr = {
    AddSubExpr
}

Assert: Expr = {
    "assert" <e:Expression> => e,
}

AddSubExpr: Expr = {
    //TODO @mark: this allows '1 +; 2' which is not desirable
    <l:AddSubExpr> "+" MayBreak <r:MulDivExpr> => Expr::BinOp(OpCode::Add, Box::new(l), Box::new(r)),
    <l:AddSubExpr> "-" MayBreak <r:MulDivExpr> => Expr::BinOp(OpCode::Sub, Box::new(l), Box::new(r)),
    MulDivExpr,
};

MulDivExpr: Expr = {
    <l:MulDivExpr> "*" MayBreak <r:NullaryExpr> => Expr::BinOp(OpCode::Mul, Box::new(l), Box::new(r)),
    <l:MulDivExpr> "/" MayBreak <r:NullaryExpr> => Expr::BinOp(OpCode::Div, Box::new(l), Box::new(r)),
    NullaryExpr,
};

NullaryExpr: Expr = {
    <s:DQSTR> => Expr::Text(s.to_string().into()),
    <s:SQSTR> => Expr::Text(s.to_string().into()),
    Single,
};

Single: Expr = {
    NumLit => Expr::Num(<>),
    Iden => Expr::IdenRead(<>),
    "(" MayBreak <e:AddSubExpr> ")" => e,
}

NumLit: f64 = <s:r"[0-9]+(\.[0-9]+)?"> => f64::from_str(s).unwrap();

StructDecl: Struct = {
    "struct" <n:Iden> "{" MayBreak <fs:Comma<FieldDecl>> "}" => Struct {
        iden: n,
        fields: fs,
    },
};

FieldDecl: (Identifier, Type) = {
    <n:Iden> ":" <t:TypeUse> => (n, t),
};

Assigns: Assignments = {
    <ds:AssignDestEq+> <e:Expression> => Assignments {
            dest: { ds },
            op: None,
            value: Box::new(e),
    },
    <d:UntypedAssignDest> <op:AssignModifier> <e:Expression> => Assignments {
        dest: { vec![d] },
        op: Some(op),
        value: Box::new(e),
    },
}

AssignDestEq: AssignmentDest = {
    <d:AssignDest> "=" => d,
}

AssignDest: AssignmentDest = {
    <UntypedAssignDest>,
    <TypedAssignDest>,
}

UntypedAssignDest: AssignmentDest = {
    <kw:AssignmentKeyword?> <n:Iden> => AssignmentDest {
            kw: kw.unwrap_or(AssignmentKw::None),
            target: n,
            typ: None,
    },
}

TypedAssignDest: AssignmentDest = {
    <kw:AssignmentKeyword?> <n:Iden> ":" <t: TypeUse> => AssignmentDest {
            kw: kw.unwrap_or(AssignmentKw::None),
            target: n,
            typ: Some(t),
    },
}

AssignmentKeyword: AssignmentKw = {
    "mut" => AssignmentKw::Mut,
    "local" => AssignmentKw::Local,
}

AssignModifier: OpCode = {
    // must treat modifier and equals as one token, because lookahead is at most 1 token
    "+=" => OpCode::Add,
    "-=" => OpCode::Sub,
    "*=" => OpCode::Mul,
    "/=" => OpCode::Div,
}

TypeUse: Type = {
    <n:Iden> => Type::new(n),
};

Iden: Identifier = <s:r"([a-zA-Z]|_[a-zA-Z0-9_])[a-zA-Z0-9_]*"> => Identifier::new(s).unwrap();

Comma<T>: Vec<T> = {
    "" => Vec::new(),
    <mut v:(<T> "," MayBreak)*> <e:T> ","? => {
        v.push(e);
        v
    }
};

Statements<T>: Vec<T> = {
    <mut v:(<T> End)*> <e:T?> => {
        if let Some(f) = e {
            v.push(f);
        }
        v
    }
};
